[TOC]



##第一章

### 1.2 Javescript 实现

- 一个完整的 JavaScript 实现应该由下列三 个不同的部分组成

   核心(ECMAScript)

   文档对象模型(DOM) 

   浏览器对象模型(BOM) 

**1.2.1 ECMAScript**

- ECMA-262定义，语法，类型，语句，关键字，保留字，操作符，对象

**1.2.2 文档对象模型（DOM）**

- 针对XML但经过扩展用于HTML的应用程序编程接口（API）
- DOM把整个页面映射为一个多层节点结构。HTML或XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据

**1.2.3 浏览器对象模型（BOM）**

- 控制浏览器显示页面以外的部分
- 处理浏览器窗口和框架，针对浏览器的JavaScript扩展也是BOM的一部分，例如：弹出新浏览器窗口的功能；移动、缩放和关闭浏览器窗口的功能; 提供浏览器详细信息的 navigator 对象; 提供浏览器所加载页面的详细信息的 location 对象; 提供用户显示器分辨率详细信息的 screen 对象; 对 cookies 的支持; 像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。

### 1.4 小结

JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成:
 ECMAScript，由 ECMA-262 定义，提供核心语言功能; 4
 文档对象模型(DOM)，提供访问和操作网页内容的方法和接口;
 浏览器对象模型(BOM)，提供与浏览器交互的方法和接口。



## 第二章 在HTML中使用JS

### 2.1 &lt;script&gt;元素

- HTML 4.0.1 定义6个属性：
  -   async:可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或 等待加载其他脚本。只对外部脚本文件有效。 
  -   charset:可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值， 因此这个属性很少有人用。 
  -   defer:可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有 效。IE7 及更早版本对嵌入脚本也支持这个属性。 
  -   language:已废弃。原来用于表示编写代码使用的脚本语言(如JavaScript、JavaScript1.2 或 VBScript)。大多数浏览器会忽略这个属性，因此也没有必要再用了。 
  -   src:可选。表示包含要执行代码的外部文件。 
  -   type:可选。可以看成是 language 的替代属性;表示编写代码使用的脚本语言的内容类型(也称为 MIME 类型)。虽然 text/javascript 和 text/ecmascript 都已经不被推荐使用，但人 们一直以来使用的都还是 text/javascript。实际上，服务器在传送 JavaScript 文件时使用的 MIME 类型通常是 application/x–javascript，但在 type 中设置这个值却可能导致脚本被 忽略。另外，在非 IE 浏览器中还可以使用以下值:application/javascript 和 application/ecmascript。考虑到约定俗成和最大限度的浏览器兼容性，目前 type 属性的值依旧还是 text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为 text/javascript。 
- 使用&lt;script>元素的方式有两种:直接在页面中嵌入 JavaScript 代码和包含外部 JavaScript文件
  - 直接插入：
    - 包含在&lt;script>元素内部的 JavaScript 代码将被从上至下依次解释。
    - 当浏览器遇到字符串"&lt;/script>"时，就会认为那是结束的&lt;/script>标签。而通过转义字符“/”(\/)可以解决这个问题 
  - 外部：
    - ` <script type="text/javascript" src="example.js"></script>`
    - 按照惯例，外部 JavaScript 文件带有.js 扩展名。但这个扩展名不是必需的，因为浏览器不会检查包含 JavaScript 的文件的扩展名。这样一来，使用 JSP、PHP 或其他服务器端语言动态生成 JavaScript 代码也就成为了可能。但是，服务器通常还是需要
      看扩展名决定为响应应用哪种 MIME 类型。如果不使用.js 扩展名，请确保服务器能返回正确的 MIME 类型。
    - 带有 src 属性的&lt;script>元素不应该在其&lt;script>和&lt;script>标签之间再
      包含额外的 JavaScript 代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码
      会被忽略。
    - 它的 src属性可以是指向当前 HTML 页面所在域之外的某个域中的完整 URL
    - 无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照&lt;script>元素在页面中出现的先后顺序对它们依次进行解析。

**2.1.1 标签的位置**

- 按照传统的做法，所有&lt;script>元素都应该放在页面的&lt;head>元素中
- 这种做法的目的就是把所有外部文件(包括 CSS 文件和 JavaScript 文件)的引用都放在相同的地方。可是，在文档的&lt;head>元素中包含所有 JavaScript 文件，意味着必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容(浏览器在遇到&lt;body>标签时才开始呈现内容)。对于那些需要很多 JavaScript 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。
- 为了避免这个问题，现代 Web 应用程序一般都把全部 JavaScript 引
  用放在&lt;body>元素中页面内容的后面。

**2.1.2 延迟脚本**

- HTML 4.01 为&lt;script>标签定义了 defer 属性。这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script>元素中设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。
- HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一
  个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。
- 在 XHTML 文档中，要把 defer 属性设置为 defer="defer"。

**2.1.3 异步脚本**

- async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer 

  不同的是，标记为 async 的脚本并不保证按照指定它们的先后顺序执行

- 指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改 DOM。
- 异步脚本一定会在页面的 load 事件前执行，但可能会在DOMContentLoaded 事件触发之前或之后执行。
- 在 XHTML 文档中，要把 async 属性设置为 async="async"。

**2.1.4 在XHTML中的用法**

- 在 HTML 中，有特殊的规则用以确定&lt;script>元素中的哪些内容可以被解析，但这些特殊的规则在 XHTML 中不适用。比较语句 a < b 中的小于号(<)在 XHTML 中将被当作开始一个新标签来解析。但是作为标签来讲，小于号后面不能跟空格，因此就会导致语法错误。

- 避免在 XHTML 中出现类似语法错误的方法有两个。一是用相应的 HTML 实体(&lt;)替换代码中所有的小于号(<)

- 用一个 CData 片段来包含 JavaScript 代码

  - 在 XHTML(XML)中，CData 片段是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。因此，在 CData 片段中就可以使用任意字符

  - 

  - ```xml
    <script type="text/javascript"><![CDATA[
        function compare(a, b) {
            if (a < b) {
                alert("A is less than B");
            } else if (a > b) {
                alert("A is greater than B");
            } else {
            		alert("A is equal to B");
            }
        }
    ]]></script>
    ```



### 2.2 嵌入代码与外部文件

使用外部文件的优点：

 **可维护性**:遍及不同 HTML 页面的 JavaScript 会造成维护问题。但把所有 JavaScript 文件都放在 一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及 HTML 标记的情况下， 集中精力编辑 JavaScript 代码。 

 **可缓存**:浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件。也就是说，如果有两个 页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的 速度。 

 **适应未来**:通过外部文件来包含 JavaScript 无须使用前面提到 XHTML 或注释 hack。HTML 和 XHTML 包含外部文件的语法是相同的。 

### 2.3 文档模式

使用文档类型（doctype）切换实现。

- 混杂模式(quirks mode)
- 标准模式(standards mode)
- 准标准模式(almost standards mode)

### 2.4 &lt;noscript>元素

- 用以在不支持 JavaScript 的浏览器中显示替代的内容
- 这个元素可以包含能够出现在文档&lt;body>中的任何 HTML 元素——&lt;script>元素除外

### 2.5 小结

把 JavaScript 插入到 HTML 页面中要使用&lt;script>元素。使用这个元素可以把 JavaScript 嵌入到 HTML 页面中，让脚本与标记混合在一起;也可以包含外部的 JavaScript 文件。而我们需要注意的地方有: 

-   在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可 以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。 
-   所有&lt;script>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和 async 属性的情况下，只有在解析完前面&lt;script>元素中的代码之后，才会开始解析后面 &lt;script>元素中的代码。 
-   由于浏览器会先解析完不使用 defer 属性的&lt;script>元素中的代码，然后再解析后面的内容， 所以一般应该把&lt;script>元素放在页面最后，即主要内容后面，&lt;/body>标签前面。 
-   使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。 
-   使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚 本按照它们在页面中出现的顺序执行。 

另外，使用&lt;noscript>元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本 的情况下，浏览器不会显示&lt;noscript>元素中的任何内容。



## 第3章 基本概念

### 3.1 语法

**3.1.1 区分大小写**

**3.1.2 标识符**

所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则 组合起来的一或多个字符: 

- 第一个字符必须是一个字母、下划线(_)或一个美元符号($); 
- 其他字符可以是字母、下划线、美元符号或数字。

按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写。例如：myCar, doSomethingImportant

**3.1.3 注释**

`//单行注释`

```javascript
/*
*
*多行注释
*
*/
```

**3.1.4 严格模式（strict mode）**

严格模式是为 JavaScript 定义了一种不同的 解析与执行模型。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码: 

```js
    "use strict";
```

它是一个编译指示(pragma)，用于告诉支持的 JavaScript 引擎切换到严格模式。

在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行:

```js
function doSomething(){
    "use strict";
    //函数体 
} 
```

**3.1.5 语句**

ECMAScript 中的语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾

### 3.2 关键字和保留字

- 关键字

  ```js
  break
  case
  catch
  continue
  debugger*
  default
  delete
  do           
  instanceof
  else         
  new
  finally      
  return
  for          
  switch
  function     
  this
  if           
  throw
  in           
  try
  typeof
  var
  void
  while
  with
  ```

- 保留字（可能在将来用作关键字）

  ```js
  abstract
  boolean
  byte
  char
  class
  const
  debugger
  double
  enum
  export
  extends
  final
  float
  goto
  implements
  import
  int
  interface
  long
  native
  package
  private
  protected
  public
  short
  static
  super 
  synchronized
  throws
  transient
  volatile 
  ```

  

### 3.3 变量

ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用 var 操作符(注意 var 是一个关键字)，后跟变量名(即一个标识符)。例如：

`var message;`

这行代码定义了一个名为 message 的变量，该变量可以用来保存任何值(像这样未经过初始化的变量，会保存一个特殊的值——undefined

ECMAScript 也支持直接初始 化变量，因此在定义变量的同时就可以设置变量的值，如下所示: 

`var message = "hi";`

在此，变量 message 中保存了一个字符串值"hi"。像这样初始化变量并不会把它标记为字符串类型; 初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值的类型，如下所示:  

```js
var message = "hi";
message = 100; // 有效，但不推荐 
```

有一点必须注意，即用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁。

可以使用一条语句定义多个变量，只要像下面这样把每个变量(初始化或不初始化均可)用逗号分 隔开即可: 

```js
    var message = "hi",
        found = false,
        age = 29; 
```

###3.4 数据类型

ECMAScript 中有 5 种简单数据类型(也称为基本数据类型):Undefined、Null、Boolean、Number和 String。还有 1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。

ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 6 种数据类型之一。

**3.4.1 typeof操作符**

用于检测给定变量的数据类型。对一个值使用 typeof 操作符可能返回下列某个字符串:

- "undefined"——如果这个值未定义;
-  "boolean"——如果这个值是布尔值；
- "string"——如果这个值是字符串;
- "number"——如果这个值是数值;
- "object"——如果这个值是对象或 null;
- "function"——如果这个值是函数。

typeof 操作符的操作数可以是变量(message)，也可以是数值字面量

从技术角度讲，函数在 ECMAScript 中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 **typeof** 操作符来区分函数和其他对象是有必要的。

**3.4.2 Undefined类型**

Undefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。

包含 undefined 值的变量与尚未定义的变量还是不一样的：

```js
var message; // 这个变量声明之后默认取得了 undefined 值
// 下面这个变量并没有声明
// var age
alert(message);
alert(age);
// "undefined" // 产生错误
alert(typeof message); //"undefined"
alert(typeof age); //"undefined"
```

对于尚未声明过的变量，只能执行一项操作，即使用 typeof 操作符检测其数据类型，对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值。

**3.4.3 Null类型**

- Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因

- undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true；

**3.4.4 Boolean类型**

- Boolean 类型是 ECMAScript 中使用得最多的一种类型，该类型只有两个字面值:true 和 false。这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于 0。
- 区分大小写

```js
var found = true;
var lost = false;
```

- 可以对任何数据类型的值调用 Boolean()函数，而且总会返回一个 Boolean 值。至于返回的这个值是 true 还是 false，取决于要转换值的数据类型及其实际值。

| 数据类型  | 转换为True的值 | 转换为false的值 |
| --------- | -------------- | --------------- |
| Boolean   | true           | false           |
| String    | 任何非空字符串 | ""              |
| Number    | 任何非零数字值 | 0和NaN          |
| Object    | 任何对象       | null            |
| Undefined | n/a            | undefined       |

**3.4.5 Number类型**

这种类型使用 IEEE754 格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。

最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入:

```js
var intNum = 55; // 整数 
```

除了以十进制表示外，整数还可以通过八进制(以 8 为基数)或十六进制(以 16 为基数)的字面值 来表示。其中，八进制字面值的第一位必须是零(0)，然后是八进制数字序列(0~7)。如果字面值中的 数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。请看下面的例子: 

```js
var octalNum1 = 070;// 八进制的 56
var octalNum2 = 079;// 无效的八进制数值——解析为 79
var octalNum3 = 08; // 无效的八进制数值——解析为 8 
```

十六进制字面值的前两位必须是 0x，后跟任何十六进制数字(0~9 及 A~F)。其中，字母 A~F 可以大写，也可以小写。如下面的例子所示: 

```js
var hexNum1 = 0xA; // 十六进制的 10 
var hexNum2 = 0x1f; // 十六进制的 31  
```

在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

1. 浮点数值

   由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 将浮点数值转换为整数值。如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数(如 1.0)，那么该值也会被转换为整数。

   对于那些极大或极小的数值，可以用 e 表示法(即科学计数法)表示的浮点数值表示。用 e 表示法 表示的数值等于 e 前面的数值乘以 10 的指数次幂。ECMAScript 中 e 表示法的格式也是如此，即前面是 一个数值(可以是整数也可以是浮点数)，中间是一个大写或小写的字母 E，后面是 10 的幂中的指数， 该幂值将用来与前面的数相乘。下面是一个使用 e 表示法表示数值的例子: 

   ```var floatNum = 3.125e7; // 等于31250000 ```

   也可以使用 e 表示法表示极小的数值，如 0.00000000000000003，这个数值可以使用更简洁的 3e-17表示。在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值(例如，0.0000003 会被转换成 3e-7)。

   浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2的结果不是 0.3，而是0.30000000000000004。

2. 数值范围

   - ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324;能够表示的最大数值保存在
     Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity(负无穷)，如果这个数值是正数，则会被转换成 Infinity(正无穷)。

   - 如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算， 因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的(换句话说，是不是位于最 小和最大的数值之间)，可以使用 isFinite()函数。这个函数在参数位于最小与最大数值之间时会返 回 true 
   - 访问 **Number.NEGATIVE_INFINITY** 和**Number.POSITIVE_INFINITY** 也可以得到负和正 **Infinity** 的值。可以想见，这两个属性中分别保存着**-Infinity** 和
     **Infinity**。

3. NaN

   - NaN，即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。例如，在其他编程语言中，任何数值除以 0 都会导致错误， 从而停止代码执行。但在 ECMAScript 中，任何数值除以 0 会返回 NaN，因此不会影响其他代码的执行。 
   - NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作(例如 NaN/10)都会返回 NaN，这
     个特点在多步计算中有可能导致问题。其次，NaN 与任何值都不相等，包括 NaN 本身。
   - 针对 NaN 的这两个特点，ECMAScript 定义了 isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试
     将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串"10"或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。
   - **isNaN()**确实也适用于对象。在基于对象调用 **isNaN()**函数时，会首先调用对象的 **valueOf()**方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 **toString()**方法，再测试返回值。

4. 数值转换

   有 3 个函数可以把非数值转换为数值:Number()、parseInt()和 parseFloat()。第一个函数， 即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个 函数对于同样的输入会有返回不同的结果。 

   - Number()
       如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。  如果是数字值，只是简单的传入和返回。
       如果是 null 值，返回 0。
       如果是 undefined，返回 NaN。
       如果是字符串，遵循下列规则: 

     ​	  如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即"1" 会变成 1，"123"会变成 123，而"011"会变成 11(注意:前导的零被忽略了); 

     ​	  如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值(同样，也会忽 略前导零); 

     ​	  如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整 数值; 

     ​	  如果字符串是空的(不包含任何字符)，则将其转换为 0; 

     ​	  如果字符串中包含除上述格式之外的字符，则将其转换为NaN。
       如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换 的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。

   - parseInt()

     - 它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN;也就是说，用 parseInt()转换空字符串会返回 NaN(Number()对空字符返回 0)。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如， "1234blue"会被转换为 1234，因为"blue"会被完全忽略。类似地，"22.5" 4会被转换为 22，因为小数点并不是有效的数字字符。

     - 如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式(即前面讨论的十进制、八进制和十六进制数)。也就是说，如果字符串以"0x"开头且后跟数字字符，就会将其当作一 5个十六进制整数;如果字符串以"0"开头且后跟数字字符，则会将其当作一个八进制数来解析。
     - 可以为这个函数提供第二个参数:转换时使用的基数(即多少进制)。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第二个参数，可以保证得到正确的结果

   - parseFloat()

     - 从第一个字符(位置 0)开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。
     - 由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。
     - 如果字符串包含的是一个可解析为整数的数(没有小数点，或者小数点后
       都是零)，parseFloat()会返回整数。

**3.4.6 string类型**

字符串可以由双引号(")或单引号(')表示 

1. 字符字面量

   String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。

   | 字面量 | 含义                                                         |
   | ------ | ------------------------------------------------------------ |
   | \n     | 换行                                                         |
   | \t     | 制表                                                         |
   | \b     | 空格                                                         |
   | \r     | 回车                                                         |
   | \f     | 进纸                                                         |
   | \\\    | 斜杠                                                         |
   | \'     | 单引号                                                       |
   | \"     | 双引号                                                       |
   | \xnn   | 以十六进制代码nn表示的一个字符，例如\41表示"A"               |
   | \unnnn | 以十六进制代码nnnn表示的一个Unicode字符，例如\u03a3表示希腊字符Σ |

   任何字符串的长度都可以通过访问其length属性取得，例如：text.length, 这个属性返回的字符数包括 16 位字符的数目。如果字符串中包含双字节字符，那么 length 属性可能不会精确地返回字符串中的字符数目。

2. 字符串的特点

   ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量

3. 转换为字符串

   要把一个值转换为一个字符串有两种方式。

   - 第一种是使用几乎每个值都有的 toString()方法。这个方法唯一要做的就是返回相应值的字符串表现。数值、布尔值、对象和字符串值(没错，每个字符串也都有一个 toString()方法，该方法返回字符串的一个副本)都有 toString()方法。但 null 和 undefined 值没有这个方法。在调用数值的 toString()方法时，可以传递一个参数:输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。

   - 在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String()，这个 函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则: 

      如果值有 toString()方法，则调用该方法(没有参数)并返回结果; 

      如果值是 null，则返回"null";

      如果值是 undefined，则返回"undefined"。

   - 要把某个值转换为字符串，可以使用加号操作符(3.5 节讨论)把它与一个字符串("")加在一起。

**3.4.7 Object类型**

ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和(或)方法，就可以创建自定义对象

```js
var o = new Object();
```

在 ECMAScript 中， (就像 Java 中的 java.lang.Object 对象一样)Object 类型是所有它的实例的基础。换句话说， Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object 的每个实例都具有下列属性和方法。 

- constructor:保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor) 8 就是 Object()。 

- hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定(例如: o.hasOwnProperty("name"))。 

- isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型(第 5 章将讨论原 型)。 

- propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句 (本章后面将会讨论)来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符 

  串形式指定。 

- toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。 
- toString():返回对象的字符串表示。 
- valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值 相同。

由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。 

### 3.5 操作符

ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符(如加号和减号)、位操作符、关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf()
和(或)toString()方法，以便取得可以操作的值。

**3.5.1 一元操作符**

只能操作一个值的操作符叫做一元操作符。

1. 递增和递减操作符

   - 前置型应该位于要操作的变量之前，而后置型则应该位于要操作的变量之后。

   - 执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。

     ```js
     var age = 29;
     var anotherAge = --age + 2;
     alert(age); // 输出28 
     alert(anotherAge); // 输出30
     ```

     由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。

   - 后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。

     ```js
     var num1 = 2;
     var num2 = 20;
     var num3 = num1-- + num2; // 等于 22
     var num4 = num1 + num2; // 等于 21
     ```

   所有这 4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则:

   - 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字 符串变量变成数值变量。 
   - 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN(第 4 章将详细讨论)。 字符串变量变成数值变量。 
   - 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。 
   - 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。 
   - 在应用于浮点数值时，执行加减 1 的操作。 
   - 在应用于对象时，先调用对象的 valueOf()方法(第 5 章将详细讨论)以取得一个可供操作的 值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规则。对象变量变成数值变量。

2. 一元加和减操作符

   1. 一元加操作符以一个加号(+)表示，放在数值前面，对数值不会产生任何影响
   2. 在对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。换句话说，布尔值 false 和 true 将被转换为 0 和 1，字符串值会被按照一组特殊的规则进行解析，而
      对象是先调用它们的 valueOf()和(或)toString()方法，再转换得到的值。
   3. 一元减操作符主要用于表示负数，例如将 1 转换成-1。在将一元减操作符应用于数值时，该值会变成负数(如上面的例子所示)。而当应用于非数值时， 一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数

**3.5.2 位操作符**

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。但这个转换过程也导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。如果对非数值应用位操作符，会先使用 Number()函数将该值转换为一个数值(自动完成)，然后再应用位操作。得到的结果将是一个数值。

- 对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号:0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储。
- 负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列 3 个步骤:
  - 求这个数值绝对值的二进制码(例如，要求-18 的二进制补码，先求 18 的二进制码);
  - 求二进制反码，即将 0 替换为 1，将 1 替换为 0;
  - 得到的二进制反码加 1。

1. 按位非(NOT)

   按位非操作符由一个波浪线(~)表示，执行按位非的结果就是返回数值的反码。按位非操作的本质:操作数的负值减 1。

2. 按位与(AND)

   按位与操作符由一个和号字符(&)表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行 AND 操作

3. 按位或(OR)

   按位或操作符由一个竖线符号(|)表示，同样也有两个操作数。

4. 按位异或(XOR)

   按位异或操作符由一个插入符号(^)表示，也有两个操作数。

5. 左移

   左移操作符由两个小于号(<<)表示，这个操作符会将数值的所有位向左移动指定的位数。左移操作会以 0 来填充这些空位，以便得到的结果是一个完整的 32 位二进制数。左移不会影响操作数的符号位。

6. 有符号的右移

   符号的右移操作符由两个大于号(>>)表示，这个操作符会将数值向右移动，但保留符号位(即正负号标记)。 在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧。而此时 ECMAScript 会用符号位的值来填充所有空位，以便得到一个完整的值。

7. 无符号右移

   无符号右移操作符由 3 个大于号(>>>)表示，这个操作符会将数值的所有 32 位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。

   但是对负数来说，情况就不一样了。首先，无符号右移是以 0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常大

**3.5.3 布尔操作符**

1. 逻辑非 

   逻辑非操作符由一个叹号(!)表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据 类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。

    如果操作数是一个对象，返回 false;
    如果操作数是一个空字符串，返回 true;
    如果操作数是一个非空字符串，返回 false;
    如果操作数是数值 0，返回 true;
    如果操作数是任意非 0 数值(包括 Infinity)，返回 false;
    如果操作数是 null，返回 true;
    如果操作数是 NaN，返回 true;
    如果操作数是 undefined，返回 true。

   逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。 

2. 逻辑与

   逻辑与操作符由两个和号(&&)表示，有两个操作数。

   逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值;此时，它遵循下列规则:

    - 如果第一个操作数是对象，返回第二个操作数
    - 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象; 
    - 如果两个操作数都是对象，则返回第二个操作数; 
    -  如果有一个操作数是 null，则返回 null; 
    - 如果有一个操作数是 NaN，则返回 NaN; 
    - 如果有一个操作数是 undefined，则返回 undefined。 

   逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是true 了。

3. 逻辑或
  逻辑或操作符由两个竖线符号(||)表示，有两个操作数。

  与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值;此时，它遵循下 列规则: 

    如果第一个操作数是对象，则返回第一个操作数;
    如果第一个操作数的求值结果为 false，则返回第二个操作数;  如果两个操作数都是对象，则返回第一个操作数;
    如果两个操作数都是 null，则返回 null;
    如果两个操作数都是 NaN，则返回 NaN;
    如果两个操作数都是 undefined，则返回 undefined。 

  与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为
  true，就不会对第二个操作数求值了。

**3.5.4 乘性操作符**

如果参与乘性计算的某个操作数不是数值，后台会先使用 Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值 true 将被当作 1。

1. 乘法（*）

   在处理特殊值的情况下，乘法操作符遵循下列特殊的规则:

   -  如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围， 6 则返回 Infinity 或-Infinity; 

   -   如果有一个操作数是 NaN，则结果是 NaN; 

   -   如果是 Infinity 与 0 相乘，则结果是 NaN; 

   -   如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数 

     的符号; 

   -   如果是 Infinity 与 Infinity 相乘，则结果是 Infinity; 

   -   如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 

2. 除法（/）

   与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下:

   -  如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围， 11 

   则返回 Infinity 或-Infinity; 

   -   如果有一个操作数是 NaN，则结果是 NaN; 
   -   如果是 Infinity 被 Infinity 除，则结果是 NaN; 
   -   如果是零被零除，则结果是 NaN; 
   -   如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号; 
   -   如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号; 
   -  如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。

3. 求模（%）

   与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值:  如果操作数都是数值，执行常规的除法计算，返回除得的余数;
     如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN;
     如果被除数是有限大的数值而除数是零，则结果是 NaN; 

     如果是 Infinity 被 Infinity 除，则结果是 NaN;
     如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数;
     如果被除数是零，则结果是零;
     如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。

**3.5.5 加性操作符**

1. 加法

   如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果:  如果有一个操作数是 NaN，则结果是 NaN;
     如果是 Infinity 加 Infinity，则结果是 Infinity;
     如果是-Infinity 加-Infinity，则结果是-Infinity; 

     如果是 Infinity 加-Infinity，则结果是 NaN; 

     如果是+0 加+0，则结果是+0;
     如果是-0 加-0，则结果是-0;
     如果是+0 加-0，则结果是+0。 

   不过，如果有一个操作数是字符串，那么就要应用如下规则:

- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来; 

- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

- 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值， 

  然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串"undefined"和"null"。 

  如果想先对数值执行算术计算，然后再将结果与字符串拼接起来，应该像下面这样使用
  圆括号:

  ```js
  var num1 = 5;
  var num2 = 10;
  var message = "The sum of 5 and 10 is " + (num1 + num2); alert(message); //"The sum of 5 and 10 is 15"
  ```

2. 减法

   与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些 特殊规则，如下所示: 

    如果两个操作符都是数值，则执行常规的算术减法操作并返回结果;  如果有一个操作数是 NaN，则结果是 NaN;
     如果是 Infinity 减 Infinity，则结果是 NaN;
     如果是-Infinity 减-Infinity，则结果是 NaN; 

     如果是 Infinity 减-Infinity，则结果是 Infinity; 

     如果是-Infinity 减 Infinity，则结果是-Infinity; 

     如果是+0 减+0，则结果是+0;
     如果是+0 减-0，则结果是- 0; 

      如果是-0 减-0，则结果是+0; 

      如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN; 

      如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString() 方法并将得到的字符串转换为数值。

**3.5.6 关系操作符**

与 ECMAScript 中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换 或完成某些奇怪的操作。以下就是相应的规则。 

-   如果两个操作数都是数值，则执行数值比较。 
-   如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。 
-   如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 
-   如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。 
-   如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。 

```js
var result = "a" < 3; // false，因为"a"被转换成了 NaN
```

**3.5.7 相等操作符**

1. 相等和不相等（先转换再比较）

   ECMAScript 中的相等操作符由两个等于号(==)表示，如果两个操作数相等，则返回 true。而不 相等操作符由叹号后跟等于号(!=)表示，如果两个操作数不相等，则返回 true。这两个操作符都会 先转换操作数(通常称为强制转型)，然后再比较它们的相等性。 

   在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则: 

   如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而true转换为1；

   -   如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值; 
   -   如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较; 

   这两个操作符在进行比较时则要遵循下列规则。

   -   null 和 undefined 是相等的。 

   -   要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 

   -   如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示: 

     即使两个操作数都是 NaN，相等操作符也返回 false;因为按照规则，NaN 不等于 NaN。 

   -   如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 

     则相等操作符返回 true;否则，返回 false。 

2. 全等和不全等（仅比较而不转换）

   除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全
   等操作符由 3 个等于号(===)表示，它只在两个操作数未经转换就相等的情况下返回 true.
   
   不全等操作符由一个叹号后跟两个等于号(!==)表示，它在两个操作数未经转换就不相等的情况
   下返回 true。
   
   null == undefined 会返回 true，因为它们是类似的值;但 null === undefined 会返回 false，因为它们是不同类型的值。

**3.5.8 条件操作符**

```js
variable = boolean_expression ? true_value : false_value;
var max = (num1 > num2) ? num1 : num2; //example
```

**3.5.9 赋值操作符**

简单的赋值操作符由等于号(=)表示，其作用就是把右侧的值赋给左侧的变量

如果在等于号(=)前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。

  乘/赋值(*=);
  除/赋值(/=);
  模/赋值(%=); 

  加/赋值(+=);
  减/赋值(=);
  左移/赋值(<<=);
  有符号右移/赋值(>>=); 

  无符号右移/赋值(>>>=)

设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。

**3.5.10 逗号操作符**

使用逗号操作符可以在一条语句中执行多个操作，逗号操作符多用于声明多个变量;但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项

```js
var num = (5, 1, 4, 8, 0); // num的值为0
```

### 3.6 语句

**3.6.1 if语句**

始终使用代码块

**3.6.2 do-while语句**

do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。
换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。

```js
do {
    statement
} while (expression);
```

**3.6.3 while语句**

while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。循环体内的代码可能永远不会被执行。

**3.6.4 for语句**

for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。

for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部
省略，就会创建一个无限循环：

```js
for (;;){
  doSomething();
}
```

**3.6.5 for-in语句**

for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。

```js
for (property in expression) statement
//example
for (var propName in window) {
     document.write(propName);
}
```

与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是, 为了保证使用局部变量，我们推荐上面例子中的这种做法。

ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。
具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。

**3.6.6 label语句**

